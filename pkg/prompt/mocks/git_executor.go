// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"os/exec"
	"sync"
)

// GitExecutorMock is a mock implementation of prompt.GitExecutor.
//
//	func TestSomethingThatUsesGitExecutor(t *testing.T) {
//
//		// make and configure a mocked prompt.GitExecutor
//		mockedGitExecutor := &GitExecutorMock{
//			CommandFunc: func(name string, args ...string) *exec.Cmd {
//				panic("mock out the Command method")
//			},
//			CommandOutputFunc: func(cmd *exec.Cmd) ([]byte, error) {
//				panic("mock out the CommandOutput method")
//			},
//			CommandRunFunc: func(cmd *exec.Cmd) error {
//				panic("mock out the CommandRun method")
//			},
//			LookPathFunc: func(file string) (string, error) {
//				panic("mock out the LookPath method")
//			},
//		}
//
//		// use mockedGitExecutor in code that requires prompt.GitExecutor
//		// and then make assertions.
//
//	}
type GitExecutorMock struct {
	// CommandFunc mocks the Command method.
	CommandFunc func(name string, args ...string) *exec.Cmd

	// CommandOutputFunc mocks the CommandOutput method.
	CommandOutputFunc func(cmd *exec.Cmd) ([]byte, error)

	// CommandRunFunc mocks the CommandRun method.
	CommandRunFunc func(cmd *exec.Cmd) error

	// LookPathFunc mocks the LookPath method.
	LookPathFunc func(file string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Command holds details about calls to the Command method.
		Command []struct {
			// Name is the name argument value.
			Name string
			// Args is the args argument value.
			Args []string
		}
		// CommandOutput holds details about calls to the CommandOutput method.
		CommandOutput []struct {
			// Cmd is the cmd argument value.
			Cmd *exec.Cmd
		}
		// CommandRun holds details about calls to the CommandRun method.
		CommandRun []struct {
			// Cmd is the cmd argument value.
			Cmd *exec.Cmd
		}
		// LookPath holds details about calls to the LookPath method.
		LookPath []struct {
			// File is the file argument value.
			File string
		}
	}
	lockCommand       sync.RWMutex
	lockCommandOutput sync.RWMutex
	lockCommandRun    sync.RWMutex
	lockLookPath      sync.RWMutex
}

// Command calls CommandFunc.
func (mock *GitExecutorMock) Command(name string, args ...string) *exec.Cmd {
	if mock.CommandFunc == nil {
		panic("GitExecutorMock.CommandFunc: method is nil but GitExecutor.Command was just called")
	}
	callInfo := struct {
		Name string
		Args []string
	}{
		Name: name,
		Args: args,
	}
	mock.lockCommand.Lock()
	mock.calls.Command = append(mock.calls.Command, callInfo)
	mock.lockCommand.Unlock()
	return mock.CommandFunc(name, args...)
}

// CommandCalls gets all the calls that were made to Command.
// Check the length with:
//
//	len(mockedGitExecutor.CommandCalls())
func (mock *GitExecutorMock) CommandCalls() []struct {
	Name string
	Args []string
} {
	var calls []struct {
		Name string
		Args []string
	}
	mock.lockCommand.RLock()
	calls = mock.calls.Command
	mock.lockCommand.RUnlock()
	return calls
}

// CommandOutput calls CommandOutputFunc.
func (mock *GitExecutorMock) CommandOutput(cmd *exec.Cmd) ([]byte, error) {
	if mock.CommandOutputFunc == nil {
		panic("GitExecutorMock.CommandOutputFunc: method is nil but GitExecutor.CommandOutput was just called")
	}
	callInfo := struct {
		Cmd *exec.Cmd
	}{
		Cmd: cmd,
	}
	mock.lockCommandOutput.Lock()
	mock.calls.CommandOutput = append(mock.calls.CommandOutput, callInfo)
	mock.lockCommandOutput.Unlock()
	return mock.CommandOutputFunc(cmd)
}

// CommandOutputCalls gets all the calls that were made to CommandOutput.
// Check the length with:
//
//	len(mockedGitExecutor.CommandOutputCalls())
func (mock *GitExecutorMock) CommandOutputCalls() []struct {
	Cmd *exec.Cmd
} {
	var calls []struct {
		Cmd *exec.Cmd
	}
	mock.lockCommandOutput.RLock()
	calls = mock.calls.CommandOutput
	mock.lockCommandOutput.RUnlock()
	return calls
}

// CommandRun calls CommandRunFunc.
func (mock *GitExecutorMock) CommandRun(cmd *exec.Cmd) error {
	if mock.CommandRunFunc == nil {
		panic("GitExecutorMock.CommandRunFunc: method is nil but GitExecutor.CommandRun was just called")
	}
	callInfo := struct {
		Cmd *exec.Cmd
	}{
		Cmd: cmd,
	}
	mock.lockCommandRun.Lock()
	mock.calls.CommandRun = append(mock.calls.CommandRun, callInfo)
	mock.lockCommandRun.Unlock()
	return mock.CommandRunFunc(cmd)
}

// CommandRunCalls gets all the calls that were made to CommandRun.
// Check the length with:
//
//	len(mockedGitExecutor.CommandRunCalls())
func (mock *GitExecutorMock) CommandRunCalls() []struct {
	Cmd *exec.Cmd
} {
	var calls []struct {
		Cmd *exec.Cmd
	}
	mock.lockCommandRun.RLock()
	calls = mock.calls.CommandRun
	mock.lockCommandRun.RUnlock()
	return calls
}

// LookPath calls LookPathFunc.
func (mock *GitExecutorMock) LookPath(file string) (string, error) {
	if mock.LookPathFunc == nil {
		panic("GitExecutorMock.LookPathFunc: method is nil but GitExecutor.LookPath was just called")
	}
	callInfo := struct {
		File string
	}{
		File: file,
	}
	mock.lockLookPath.Lock()
	mock.calls.LookPath = append(mock.calls.LookPath, callInfo)
	mock.lockLookPath.Unlock()
	return mock.LookPathFunc(file)
}

// LookPathCalls gets all the calls that were made to LookPath.
// Check the length with:
//
//	len(mockedGitExecutor.LookPathCalls())
func (mock *GitExecutorMock) LookPathCalls() []struct {
	File string
} {
	var calls []struct {
		File string
	}
	mock.lockLookPath.RLock()
	calls = mock.calls.LookPath
	mock.lockLookPath.RUnlock()
	return calls
}
