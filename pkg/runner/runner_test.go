package runner

import (
	"context"
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/umputun/mpt/pkg/runner/mocks"
)

func TestRunner_Run(t *testing.T) {
	t.Run("all providers successful", func(t *testing.T) {
		provider1 := &mocks.ProviderMock{
			NameFunc: func() string {
				return "Provider1"
			},
			GenerateFunc: func(ctx context.Context, prompt string) (string, error) {
				return "Response 1", nil
			},
			EnabledFunc: func() bool {
				return true
			},
		}

		provider2 := &mocks.ProviderMock{
			NameFunc: func() string {
				return "Provider2"
			},
			GenerateFunc: func(ctx context.Context, prompt string) (string, error) {
				return "Response 2", nil
			},
			EnabledFunc: func() bool {
				return true
			},
		}

		runner := New(provider1, provider2)
		result, err := runner.Run(context.Background(), "test prompt")

		require.NoError(t, err)
		assert.Contains(t, result, "== generated by Provider1 ==")
		assert.Contains(t, result, "Response 1")
		assert.Contains(t, result, "== generated by Provider2 ==")
		assert.Contains(t, result, "Response 2")

		// verify the mock was called with expected parameters
		require.Equal(t, 1, len(provider1.GenerateCalls()))
		assert.Equal(t, "test prompt", provider1.GenerateCalls()[0].Prompt)
		require.Equal(t, 1, len(provider2.GenerateCalls()))
		assert.Equal(t, "test prompt", provider2.GenerateCalls()[0].Prompt)
	})

	t.Run("single provider skips header", func(t *testing.T) {
		provider1 := &mocks.ProviderMock{
			NameFunc: func() string {
				return "Provider1"
			},
			GenerateFunc: func(ctx context.Context, prompt string) (string, error) {
				return "Response 1", nil
			},
			EnabledFunc: func() bool {
				return true
			},
		}

		runner := New(provider1)
		result, err := runner.Run(context.Background(), "test prompt")

		require.NoError(t, err)
		assert.Equal(t, "Response 1", result)
		assert.NotContains(t, result, "== generated by Provider1 ==")

		// verify the mock was called with expected parameters
		require.Equal(t, 1, len(provider1.GenerateCalls()))
		assert.Equal(t, "test prompt", provider1.GenerateCalls()[0].Prompt)
	})

	t.Run("single provider with error", func(t *testing.T) {
		provider1 := &mocks.ProviderMock{
			NameFunc: func() string {
				return "Provider1"
			},
			GenerateFunc: func(ctx context.Context, prompt string) (string, error) {
				return "", errors.New("test error")
			},
			EnabledFunc: func() bool {
				return true
			},
		}

		runner := New(provider1)
		result, err := runner.Run(context.Background(), "test prompt")

		require.NoError(t, err)
		assert.Equal(t, "test error", result)
		assert.NotContains(t, result, "== generated by Provider1 ==")

		// verify the mock was called with expected parameters
		require.Equal(t, 1, len(provider1.GenerateCalls()))
		assert.Equal(t, "test prompt", provider1.GenerateCalls()[0].Prompt)
	})

	t.Run("some providers fail", func(t *testing.T) {
		provider1 := &mocks.ProviderMock{
			NameFunc: func() string {
				return "Provider1"
			},
			GenerateFunc: func(ctx context.Context, prompt string) (string, error) {
				return "", errors.New("provider 1 error")
			},
			EnabledFunc: func() bool {
				return true
			},
		}

		provider2 := &mocks.ProviderMock{
			NameFunc: func() string {
				return "Provider2"
			},
			GenerateFunc: func(ctx context.Context, prompt string) (string, error) {
				return "Response 2", nil
			},
			EnabledFunc: func() bool {
				return true
			},
		}

		runner := New(provider1, provider2)
		result, err := runner.Run(context.Background(), "test prompt")

		require.NoError(t, err)
		assert.Contains(t, result, "== generated by Provider1 ==")
		assert.Contains(t, result, "provider 1 error")
		assert.Contains(t, result, "== generated by Provider2 ==")
		assert.Contains(t, result, "Response 2")
	})

	t.Run("no enabled providers", func(t *testing.T) {
		provider1 := &mocks.ProviderMock{
			NameFunc: func() string {
				return "Provider1"
			},
			EnabledFunc: func() bool {
				return false
			},
		}

		provider2 := &mocks.ProviderMock{
			NameFunc: func() string {
				return "Provider2"
			},
			EnabledFunc: func() bool {
				return false
			},
		}

		runner := New(provider1, provider2)
		_, err := runner.Run(context.Background(), "test prompt")

		require.Error(t, err)
		assert.Contains(t, err.Error(), "no enabled providers")
	})

	t.Run("single provider with multiline response", func(t *testing.T) {
		provider := &mocks.ProviderMock{
			NameFunc: func() string {
				return "MultilineProvider"
			},
			GenerateFunc: func(ctx context.Context, prompt string) (string, error) {
				return "Line 1\nLine 2\nLine 3", nil
			},
			EnabledFunc: func() bool {
				return true
			},
		}

		runner := New(provider)
		result, err := runner.Run(context.Background(), "multiline test")

		require.NoError(t, err)
		assert.Equal(t, "Line 1\nLine 2\nLine 3", result)
		assert.NotContains(t, result, "== generated by MultilineProvider ==")

		// verify the mock was called with expected parameters
		require.Equal(t, 1, len(provider.GenerateCalls()))
		assert.Equal(t, "multiline test", provider.GenerateCalls()[0].Prompt)
	})
}
